<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-config-udev">
  <?dbhtml filename="udev.html"?>

  <title>Обработка устройств и модулей</title>

  <indexterm zone="ch-config-udev">
    <primary sortas="a-Udev">Udev</primary>
    <secondary>usage</secondary>
  </indexterm>

  <para>Ранее, в шестой главе, был установлен пакет
  <phrase revision="sysv">eudev</phrase> <phrase revision="systemd">systemd</phrase>.
  Перед тем, как приступить к описанию процесса как это работает, будет кратко рассказана
  история предыдущих методов работы устройств.</para>

  <para>Системы Linux традиционно используют метод статического создания устройств,
  посредством чего, большое число узлов устройств (иногда буквально тысячи узлов)
  создается в каталоге <filename class="directory">/dev</filename>, независимо от
  того, существуют ли соответствующие аппаратные устройства. Это обычно делается
  средствами сценария <command>MAKEDEV</command>, который содержит команды вызова
  программы <command>mknod</command> с соответствующим числом для каждого возможного
  устройства которое только может существовать в мире.</para>

  <para>Используя метод udev, только те устройства, которые были обнаружены ядром,
  получают свой узел. Поскольку эти узлы будут создаваться каждый раз, при загрузке
  системы, они будут располагаться в каталоге виртуальной файловой
  системы <systemitem class="filesystem">devtmpfs</systemitem> (виртуальная файловая
  система, которая полностью находится в оперативной памяти). Узлы не занимают много
  места в памяти, и их общий размер незначителен.</para>

  <sect2>
    <title>История</title>

    <para>В феврале 2000 года, новая файловая система <systemitem
    class="filesystem">devfs</systemitem> была принята в ветку ядра 2.3.46 и была
    доступна на протяжении выпуска стабильных релизов ветки 2.4. Хотя она и
    присутствовала в ядре, такой способ динамического создания устройств никогда не
    получал поддержки от разработчиков ядра.</para>

    <para>Главная проблема в этом подходе заключалась в механизме обнаружения,
    создания и назначения имен устройствам. Последняя из которых, связанная с
    назначением имен узлам устройств была, самой важной. Как правило, если имена
    устройствам можно настраивать, то политика назначения имён должна быть установлена
    системным администратором и не должна быть навязана разработчиками. Файловая
    система <systemitem
    class="filesystem">devfs</systemitem> также страдала от условий гонки, которые
    были присущи ее дизайну и не могли быть исправлены без существенной переработки
    самого ядра. В конечном счёте, эта файловая система была отмечена как устаревшая,
    на протяжении достаточно долгого периода, по причине отсутствия её ненадлежащей
    поддержки, и была удалена из ветки ядра в июне 2006 года.</para>

    <para>При развитии нестабильной ветки ядра 2.5, позднее, выпущенной как стабильный
    релиз 2.6, появилась новая виртуальная файловая система
    <systemitem class="filesystem">sysfs</systemitem>. Задача этой файловой системы
    заключалась в экспорте представления об аппаратной конфигурации системы в процессах
    пользовательского окружения. Благодаря этому, разработка замены пользовательского
    окружения для <systemitem class="filesystem">devfs</systemitem> стала гораздо
    реалистичнее.</para>

  </sect2>

  <sect2>
    <title>Реализация Udev</title>

    <sect3>
      <title>Sysfs</title>

      <para>Краткое описание файловой системы <systemitem class="filesystem">sysfs</systemitem> было представлено выше. Можно задаться вопросом, как <systemitem class="filesystem">sysfs</systemitem> получает информацию об устройствах в системе, и о том, какие номера устройств должны использоваться для них. Драйверы, скомпилированные в ядро, напрямую регистрируют объекты с помощью <systemitem class="filesystem">sysfs</systemitem> ( внутри <systemitem class="filesystem">devtmpfs</systemitem>  ), так как они обнаруживаются ядром. Для драйверов, которые скомпилированы в виде модулей, регистрация будет происходить при его загрузке. После того, как файловая система <systemitem class="filesystem">sysfs</systemitem> будет примонтирована в каталог <filename class="directory">/sys</filename>, данные, которые регистрируются драйверами, с помощью <systemitem class="filesystem">sysfs</systemitem>, станут доступны для процессов пользовательского окружения и для udevd, для последующей обработки (включая изменения узлов устройств).</para>
    </sect3>

    <sect3>
      <title>Создание узлов устройств</title>

      <para>Файлы устройств создаются ядром при помощи файловой
      системы <systemitem class="filesystem">devtmpfs</systemitem>. Любой драйвер,
      которому необходимо зарегистрировать узел устройства, будет проходить через
      файловую систему <systemitem class="filesystem">devtmpfs</systemitem> (через
      системный драйвер ядра). Когда экземпляр 
      <systemitem class="filesystem">devtmpfs</systemitem> монтируется в каталог
      <filename class="directory">/dev</filename>, узел устройства будет создан с
      фиксированным наименованием, соответствующими разрешениями и владельцем.</para>

      <para>Через некоторое время, ядро отправит uevent в <command>udevd</command>.
      На основе правил, которые указанны в файлах в каталогах
      <filename class="directory">/etc/udev/rules.d</filename>, <filename
      class="directory">/lib/udev/rules.d</filename>, и <filename
      class="directory">/run/udev/rules.d</filename>, udevd создаст дополнительные
      символические ссылки на узлы устройств, или сменит разрешения, владельца или
      группу, или сменит запись (наименование) во внутренней базе данных udevd для этого
      объекта.</para>

      <para>Правила в этих трёх каталогах нумеруются и объединяются вместе. Если
      <command>udevd</command> не может найти правило для устройства, он оставит права
      доступа и права собственности на все первоначально используемые <systemitem
      class="filesystem">devtmpfs</systemitem>.</para> </sect3>

    <sect3 id="module-loading">
      <title>Загрузка модулей</title>
      <para>Драйверы устройств, скомпилированные в виде модулей ядра могут содержать
      встроенные псевдонимы. Псевдонимы можно увидеть просмотрев вывод программы 
      <command>modinfo</command>. Они, как правило, связаны с идентификаторам шины
      устройства, поддерживаемым модулем. Например, драйвер <emphasis>snd-fm801</emphasis>
      подерживает PCI устройства с идентификатором поставщика 0x1319 и идентификатором
      устройства 0x0801, и имеет псевдоним <quote>pci:v00001319d00000801sv*sd*bc04sc01i*</quote>.
      Для большинства устройств, драйвер шины экспортирует псевдонимы драйвера, которые
      будет обрабатывать устройство через <systemitem class="filesystem">sysfs</systemitem>.
      Например, файл <filename>/sys/bus/pci/devices/0000:00:0d.0/modalias</filename> может
      содержать строку <quote>pci:v00001319d00000801sv00001319sd00001319bc04sc01i00</quote>.
      Правила по умолчанию, которые предоставлены Udev, заставят <command>udevd</command>
      вызвать <command>/sbin/modprobe</command> с содержимым, которое находится в значении
      переменной окружения <envar>MODALIAS</envar> uevent (которая должна совпадать с
      содержимым файла <filename>modalias</filename> в sysfs), тем самым загружая все
      модули, чьи псевдонимы совпадают в строке после расширение подстановочных
      знаков.</para>

      <para>К указанному выше примеру, это означает, что в дополнение к snd-fm801
      устаревший (и нежелательный) драйвер forte будет загружен, если он будет доступен.
      Ниже описано, как можно предотвратить загрузку нежелательных драйверов.</para>

      <para>Само ядро также может загружать модули для сетевых протоколов, файловых систем
      и поддержки NLS по требованию.</para>
    </sect3>

    <sect3>
      <title>Обработка устройств с горячей заменой или динамических устройств</title>

      <para>При подключении устройства, например, MP3-плеер, к универсальной последовательной
      шине (USB), ядро распознает, что устройство подключено, и сгенерирует событие
      uevent. Это событие затем обрабатывается <command>udevd</command>, как было описано
      выше.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Проблемы с загрузкой модулей и созданием устройств</title>
    <para>Есть несколько возможных проблем, когда дело доходит до автоматического
    создания узлов устройств.</para>

    <sect3>
      <title>Модуль ядра не загружается автоматически</title>

      <para>Udev будет загружать модуль, только если он имеет указанный псевдоним шины,
      и драйвер шины правильно экспортирует необходимые псевдонимы в sysfs. В других
      случаях следует организовать загрузку модуля другими способами. начиная с версии
      Linux-&linux-version;, в udev, как известно,выполняет загрузку правильно написанных
      драйверов для INPUT, IDE, PCI, USB, SCSI, SERIO, и FireWire устройств.</para>

      <para>Чтобы определить, имеет ли требуемый драйвер устройства необходимую поддержку
      Udev, запустите <command>modinfo</command> с именем модуля в качестве аргумента.
      Далее, попробуйте найти каталог устройства в 
      <filename class="directory">/sys/bus</filename> и проверьте, есть ли там
      файл <filename>modalias</filename>.</para>

      <para>Если файл <filename>modalias</filename> существует в 
      <systemitem class="filesystem">sysfs</systemitem>, то драйвер, который поддерживает
      устройство, может общаться с ним напрямую, но не имеет псевдонима, это ошибка
      в драйвере. Загрузите драйвер без помощи Udev и ожидайте, что проблема будет
      исправлена позднее.</para>

      <para>Если же в каталоге <filename class="directory">/sys/bus</filename> нет
      файла <filename>modalias</filename>, это означает, что разработчики ядра еще не
      добавили поддержку <filename>modalias</filename> к этому типу шины.
      В Linux-&linux-version;, это относится к шинам ISA. Ожидайте, что эта проблема
      будет исправлена в более поздних версиях ядра.</para>

      <para>Udev не предназначен для загрузки драйверов <quote>обёрток</quote>, таких как
      <emphasis>snd-pcm-oss</emphasis>и драйверов, не относящихся к оборудованию, например
      <emphasis>loop</emphasis></para>

    </sect3>

    <sect3>
      <title>Модуль ядра не загружается автоматически, и Udev не предназначен для его
      загрузки</title>

      <para>Если модуль <quote>обёртка</quote> только расширяет функциональность,
      которая может быть предоставлена иным модулем (например  модуль 
      <emphasis>snd-pcm-oss</emphasis> расширяет функциональность модуля 
      <emphasis>snd-pcm</emphasis>, давая возможность звуковым картам быть доступными
      для OSS приложений),  настройте <command>modprobe</command> для загрузки оболочки
      после того, как Udev загрузит обернутый модуль. Для этого добавьте строку
      <quote>softdep</quote> в файл, который находится в каталоге
      <filename>/etc/modprobe.d/<replaceable>&lt;filename&gt;</replaceable>.conf</filename>.
      Например:</para>

<screen role="nodump"><literal>softdep snd-pcm post: snd-pcm-oss</literal></screen>

      <para>Обратите внимание, что команда <quote>softdep</quote> разрешает добавлять
      <literal>pre:</literal> зависимости, или одновременно
      <literal>pre:</literal> и <literal>post:</literal>. Обратитесь к документации
      <filename>modprobe.d(5)</filename> для изучения синтаксиса и возможностей
      <quote>softdep</quote>.</para>

      <para>Если модуль не является обёрткой, и полезен сам по себе, настройте
      загрузочный сценарий модулей, чтобы он добавлялся при загрузке системы. Для
      этого добавьте имя модуля в файл <filename>/etc/sysconfig/modules</filename>
      в отдельной строке. Этот способ сработает и для оберточных модулей, но не
      является оптимальным.</para>

    </sect3>

    <sect3>
      <title>Udev загружает ненужные модули</title>

      <para>Либо не создавайте модуль, либо занесите его в черный список в файле
      <filename>/etc/modprobe.d/blacklist.conf</filename>, как это сделано с
      модулем <emphasis>forte</emphasis> в примере ниже:</para>

<screen role="nodump"><literal>blacklist forte</literal></screen>

      <para>Блокированные модули могут быть загружены вручную с явным указанием в
      команде <command>modprobe</command>.</para>

    </sect3>

    <sect3>
      <title>Udev создает устройство неправильно или создает некорректную символическую
      ссылку</title>

      <para>Это обычно происходит, если правило неожиданно совпадает с устройством. 
      Например, плохо написанное правило может соответствовать как диску SCSI
      (по желанию), так и соответствующему универсальному устройству SCSI (неправильно)
      указанному поставщиком. Найдите нарушающее правило и уточните его с помощью
      команды <command>udevadm info</command>.</para>

    </sect3>

    <sect3>
      <title>Правило Udev работает ненадежно</title>

      <para>Это может быть проявлением предыдущей проблемы. В ином случае, если
      правило использует атрибуты файловой системы 
      <systemitem class="filesystem">sysfs</systemitem>, то это может быть
      проблемой синхронизации ядра, которая будет исправлена в более поздних
      версиях ядра. Но вы можете обойти проблему, создав правило, которое
      ожидает используемый атрибут <systemitem class="filesystem">sysfs</systemitem>
      и добавляет его к файлу правил (создайте его, если он не существует).
      Пожалуйста, оповестите в списке рассылки разработчиков  LFS, если вы делаете
      это, и это помогает.</para>

    </sect3>

    <sect3>
      <title>Udev не создаёт устройство</title>

      <para>Предполагается, что драйвер статически встроен в ядро или уже загружен
      как модуль, и что вы уже проверили, что Udev не создает устройство с неправильным
      наименованием.</para>

      <para>Udev не обладает информацией, необходимой для создания узла устройства,
      если драйвер ядра не экспортирует свои данные в
      <systemitem class="filesystem">sysfs</systemitem>. Как правило, такое происходит
      с внешними драйверами, которых нет в дереве исходного кода ядра. Создайте
      статический узел в каталоге <filename>/lib/udev/devices</filename> с
      соответствующими первичными и второстепенными номерами (см. файл devices.txt
      внутри документации ядра или документации, предоставленной сторонним
      поставщиком драйвера). Статический узел будет скопирован в
      <filename class="directory">/dev</filename> с помощью <command>udev</command>.</para>

    </sect3>

    <sect3>
      <title>Порядок именования устройств изменяется случайным образом после перезагрузки</title>

      <para>Это связано с тем, что Udev обрабатывает события и загружает модули
      параллельно, а значит в непредсказуемом порядке. Это никогда не будет
      <quote>исправлено</quote>. Не следует полагаться на стабильность имен устройств
      ядра. Вместо этого создайте свои собственные правила, которые делают
      символические ссылки со стабильными именами на основе некоторых стабильных
      атрибутов устройства, таких как серийный номер или вывод различных утилит
      *_id, установленных Udev. См. разделы <xref linkend="ch-config-symlinks"/>
      и <xref linkend="ch-config-network"/> для примера.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Полезно для ознакомления</title>

    <para>Дополнительная полезная документация доступна по следующим ссылкам:</para>

    <itemizedlist>

      <listitem>
        <para>Реализация  <systemitem class="filesystem">devfs</systemitem> в пользовательском окружении
        <ulink url="http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf"/></para>
      </listitem>

      <listitem>
        <para>Файловая система <systemitem class="filesystem">sysfs</systemitem>
        <ulink url="http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf"/></para>
      </listitem>

<!--  No longer available
      <listitem>
        <para>Pointers to further reading
        <ulink url="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev.html"/>
        </para>
      </listitem>
-->
    </itemizedlist>

  </sect2>

</sect1>
